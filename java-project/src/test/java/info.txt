======================
Инфраструктура.
======================
    Среда разработки - IDEA
    Сборщик - Gradle
    Хранилище пакетов - Maven Central
    Тестовый фреймворк - jUnit

Модуль состоит из двух частей
    main - модуля для прогрммы
    test - модуль для тестов

При подключении зависимостей можем указывать тип зависимостей
    dependencies {
        testCompile - режим подключения для тестовой части
        Compile - подключаем для всех модулей
        implementation 'org.seleniumhq.selenium:htmlunit-driver:2.47.1'
    }
======================
Классификация команд
======================
    * Инициализация драйвера -
         который запускает браузера (создается объект класса, при вызове конструктора запускается вспомогательный исполняемый файл, который запускает браузер). Не может уже подключиться к браузеру который уже запущен.
    * Настройка драйвера -
        таймаут, удаление и добавлени куки и др.
    * Действия со страницами -
        переход на страницу, форвард бэк
    * Действия с окнами -
        переключаться м-у окнами, умеет закрывать текущее окно.
    * Действия с диалогами -
        окошки при работе с браузерами (ok, cancel), окна при подгрузке файлов.
    * Поиск элементов (владеть в совершенстве) -

    * Свойства элементов -
        что за тег, какие атрибуты, положение элемента на странице, стили, шрифт, цвет.

    * Действия с элементами -
        нажатие клавиатуры и нажатие мышки

    * Действия с фреймами -
        работами с окнами фрейма

    * Выполнения js кода -
        выполнение кода на странице приложения
======================
=Открытие страницы
======================
    https:// - вводить обязательно
    driver.get("https://www.google.com");

=====================
 = Поиск элементов =
=====================
    Выполнять поиск элемента перед использованием
    NoSuchElementException - ошибка при поиске элемента.

===================
 = Capabilities =
===================
    Используется чтобы передовать конфигурацию браузеру, передаются в конструктор драйвера.
    по факту часть настроек передается опции командной строки при запуски браузера, другая часть
    настроек   может внедряться в запущенный браузер.

    // передаем параметры в конструктор вебдрайвера.
    var-1
    ChromeOptions options = new ChromeOptions();
    options.addArguments("start-fullscreen");
    driver = new ChromeDriver(options);

    //or var-2 если надо указать еще дополнительные настройки типа прокси.
    ChromeOptions options = new ChromeOptions();
    options.addArguments("start-fullscreen");
    DesiredCapabilities caps = new DesiredCapabilities();
    caps.setCapability(ChromeOptions.CAPABILITY, options);
    driver = new ChromeDriver(caps);

===================
= Псевдо браузеры =
===================
    Их большое количество но по факту реализация не самая лучшая и селениум не все поддерживает. Сейчас актуально использовать Docker, где можно упаковать браузер внутрь контейнера и там запускается.

===================
  = Cookies =
===================
    * Предварительный вход (добавление cookies).
    * Аутентификация в социальных сетях
    * Очистка сессии (удаление всех cookies)
    * Удаляются куки только для текущей страницы (домена), но лучше перезапустить браузер и почистятся все куки.

==========================
= Несколько браузеров =
==========================
    * Надо быть внимательным с IE много нюансов.

==================================
= Параллельный запуск браузеров =
==================================
    * Возможен только в java
    * Можно использовать для параллельного запуска браузеров вспомогательный
     класс webdriverFactory

==============================
= DOM(Document Object Model) =
==============================
    Осуществляется поиск в объектной модели документа

==============================
= Локаторы =
==============================
    Стратегии поиска -
      * By.id
      * By.tagName
      * By.className
      * By.cssSelector
      * By.name
      * By.linkText
      * By.partialLinkText
      * By.xpath

      driver.findElement(By.id("first"));
      driver.findElement(By.name("first"));
      driver.findElement(By.xpath("first"));
      driver.findElement(By.tagName("table"));
      driver.findElement(By.className("first"));
      driver.findElement(By.cssSelector("#first"));
      driver.findElement(By.linkText("Cсылка на страницу"));
      driver.findElement(By.partialLinkText("Cсылка"));
      // Выстраиный запрос в цепочку
      driver.findElement(By.id("second")).findElement(By.tagName("a"));

==============================
= Css - селекоры =
==============================
    Специальные атрибуты -
        id - ("#username")
        class - (".username")

    Проверка значений атрибута
         [checked] - наличие атрибута
         [name = email] - совпадение значение
         [title *= Name] - содержит текст
         [src ^= http] - начинается с текста
         [src $= .pdf] - заканчивается текстом

    Отрицание условий
        "label:not(.error)" - сообщения не об ошибках
        "input:not([type = text])" - не текстовые поля
        "a:not([href ^= http])" - локальные ссылки

    Движение по дереву (состовные селекторы)
        "div#main p " -
        "div#main > p " - p родитель которого div#main
        "div#main li:first-child " -
        "div#main li:last-child " -
        "div#main li:nth-child(1)" -
        "div#header > div:nth-of-type(1)" -

==============================
= Локаторы на основе XPath =
==============================
    Язык запросов XPath был создан для работы с xml документами
    "//*[@checked]" -
        "//" найти где то на странице, * - любой тег
    "//div[@id = 'main']/p" -
        найти тег div c id = main и там найти доч. элемент p
    form = driver.findElement(...);
    input = form.findElement(By.xpath('.//div[@id = 'main']/p'))
         ".//" найти относительно текущего элемента form.

    * Проверка значения атрибута
        Css - селекторы       XPath - запросы
        [checked]             //*[@checked]
        [name = email]        //*[@name = 'email']
        [title *= Name]       //*[contains(@title, 'Name')]
        [src ^= http]         //*[@starts-with(@src, 'http')]
        [src $= .pdf]

    * Комбинация условий
        Css - селекторы                   XPath - запросы
        "label"                           "//label"
        ".error"                          "//*[contains(@class, 'error')]"
        "label.error"                     "//label[contains(@class, 'error')]"
        "label.error.fatal"               "//label[contains(@class, 'error') and contains(@class, 'fatal')]"
        "label.error.fatal[for = email]"  "//label[contains(@class, 'error') and contains(@class, 'fatal') and @for='email']"

    * Движение по дереву CSS vs XPath
        Css - селекторы                         XPath - запросы
        "div#main p"                            "//div[@id = 'main']"
        "div#main > p"                          "//div[@id = 'main']/p"
        "div#main li:first-child"               --/--/--
        "div#main li:last-child"                --/--/--
        "div#main > div:nth-of-type(2)"       "//div[@id='main']/div[2]"

    * XPath мощнее чем CSS
        - Движение в любом направлении
            /../ - движение вверх по дереву элементов
            "//input[@id='search']/../input[@type='button']"
        - Поиск по тексту
            //a[contains(.,'Edit')]
        - Подзапросы
             Поиск input[@name='password'] относительно текущего тега form.
            //form[.//input[@name='password']]

============================
= Сравнение типа локаторов =
============================
   * Смотря как сравнивать
        Мощность запросов - XPath
        Краткость и понятность - CSS (важный момент)
        Скорость - CSS (с минимальным преимуществом)

===============================
= Поиск относительно элемента =
===============================
    * Контекст поиска -
        объект в котором вызывается команда findElement.

    driver.findElement(...) -
        контекст поиска вся страница.
    form = driver.findElement(...);
    input = form.findElement(By.xpath('.//div[@id = 'main']/p'))
        ".//" - контекст поиска form.

===============================
= Поиск нескольких элементов  =
===============================
    * Проверка наличия локатора
        Один из оптимальныз вариантов проверки.
            boolean isElementPresent(WebDriver driver, By locator){
                return driver.findElements(locator).size() > 0;
            }
         В других случаях надо быть внимательным так как
         при каждом падении селениум может делать скриншоты и это
         занимает пространство на диске.

======================
= Элемент не найден  =
======================
    * Желательно перехватывать больше исключений, так как могут подавляться
    исключения которые покажут реальную картину событий и скроют некоторые  баги
    геккодрайвера или хром драйвера. Подход (FailFast), падай как можно быстрее.

    boolean isElementPresent(Webdriver diver, locator){
        try{
            driver.findElement(locator);
            return true;
        //так можем определить не валидный локатор
        }catch(InvalidSelectorException ex){
            throw ex;
        }catch(NoSuchElementException ex){
            return false;
        }
    }
================================
= Ожидание появление элемента  =
================================
    * Причины ожидания
        - Не та страница открыта (можно сделать скриншот для проверки)
        - Неправильный локатор
        - Элемент находится внутри фрейма
        - Нужно немного подождать (подгрузка страницы)

    * Неявные(implicitlyWaiе) и Явные (Explicit Wait) ожидания
        - Неявное (косвенное, скрытое) ожидание устанавливается один раз в коде вне
            операции поиска и действительно до изменения. Не очень удобно если надо
            проверить отсутствие элемента, так как постоянно будет подвесать.
            //изменили настройки браузера
            driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);

        - Явное
            (непосредственное, прямое) ожидание используется "здесь и сейчас"
            на один конкретный поиск элемента.
            WebElement explicitWait = (new WebDriverWait(driver, 10))
            // или пока не появился элемент с id=bar
              .until(ExpectedConditions.presenceOfElementLocated(By.id("bar")));

==============================
= Построение локаторов =
==============================
    * Устойчивы к изменениям верстки
		- Максимально точные критерии выбора
			можно протестить в консоле браузера для страницы сайта
			$$("header .main-search [name='q']")
			$x("//input[contains(@class, 'main-search-input') and @name='q']")
		- Как можно меньше порядковых номеров
		- Привязка к ближайшему уникальному элементу
		- Минимум прыжков по DOM
		
===============================
= Поиск при помощи JavaScript =
===============================	
	* Пример реализации метода для использования js 
		WebDriver driver = new AnyDriverYouWant();
		JavascriptExecutor js;
		if (driver instanceof JavascriptExecutor) {
			js = (JavascriptExecutor)driver;
		} else {
			throw new IllegalStateException("This driver does not support JavaScript!");
		}

		// later on...
		js.executeScript("return document.getElementById('someId');");
	
=====================================================
= Свойства и атрибуты. Получение атрибутов элемента =
=====================================================
    * В дереве элементов DOM мы видим атрибуты
	* В консоли браузера (Elements > колонка properties ), видим набор
	  свойств элементов так как каждый элемент дерева есть узел или объект 
	  js который обладает определенным набором свойств.
	
	* getAttribute - 
		Возвращает значение свойств.
		driver.findElement(By.id("keyPad_UserInput")).getAttribute("value")
	* href, src - 
		нормализация адресов (селениум возвращает адрес свойства)
		driver.findElement(By.id("keyPad_UserInput")).getAttribute("href")
	* true или null - 
		булевские атрибуты. (если атрибут есть то селениум возвращает true)
		Например атрибут select, чтобы он не содержал селениум вернет true
		Всегда проверяйте что лежит в properties этого элемента.
		
===================================
= Определение видимости элементов =
===================================
	* Selenium врет про видимость 
		- Прозрачные элементы (только 100% прозрачные == прозрачные)
		- Элементы цвета фона (белый текст на белом фоне я-ся видимым)
		- Эл-ты, скрытые позади других элементов
		- Эл-ты за краеми экрана
		
==================
= Текст элемента =
==================
	* Видимый элемент - 
		 element.getText()
		 
	* Альтернатива(работает для скрытых элементов) - 
		 element.getAttribute("textContent")
	
	* Нормализованный текст (удаляет лишние пробелы)
	* Performatted <pre> пример </pre> (возвращает текст в такой форме как есть)
	* Не используйте для элементов форм!
	
==============================
= Получение стилей элементов =
==============================	
	* Стиль элемента
	Разработчики драйвера договорились возвращать в едином формать только цвет в формате RGBa.
	Поэтому лучше стилевые вещи проверять глазами.
	
	* Примеры методов - 
		element.getTagName, element.getAttribute("id"), element.getAttribute("class")
		element.getCssValue() - 
			возвращает разные данные в зависимости от браузера, в едином формате возвращается только  цвет.
	* Вывод
		Лучше проверять при помощи QA: 
			element.getTagName, 
			element.getAttribute("id"), element.getAttribute("class")
		Проверка в ручную:
			цвета, размеры и др.
			
================================
= Размер и положение элементов =
================================			
	* Функции
		getSize (без учета transform в CSS(chrome)) - значение возвращает в px.
		getLocation - положение на странице
		getRect (selenium 3) - размер и положение
		
	* Секретный интерфейс Locatable - 
		- (Locatable element).getCoordinates().inView()
		-------------------------------------------------
		Скролирует к нужному элементу и пытается вычеслить 
		его положение на странице. Удобно при работе с canvas,
		когда необходимо выполнять счелчки мыши по координатам.		
		
===========================
= Клик левой клавиши мыши =
===========================	
	* Когда кликнуть нельзя?
		- Элемент исчез из DOM 
		  (ошибка типа: Stale Element Reference Exception)
		
		- Элемент неинтерактивный. 
          (www.w3.org/TR/webdriver/#interactability)		
	 
		- Элемент невидимый (упрощенный вариант)
		  (selenium.ElementNotVisibleException)
		
		- Элемент закрыт другим элементом (проверить можно  только в chromedriver)  
	
	* Куда кликает Selenium? 
		(Для ChromeDriver реализовано)
		- В центре элемента
		- в центре первого элемента
		- в центре видимого прямоугольника
		
		- В видимую точку любого прямоугольника(пока что не реализовано)
	 
=============== 
= Ввод текста =
===============	
	* Когда печатать нельзя?
		- Элемент исчез из DOM. 
		- Элемент неинтерактивный.
		- Элемент невидимый.
	!!!Можно вводить текст в элемент к-й закрыт другим элементом, если нажать tab (навести фокус).
	
	* Как "печатает" Selenium?
		- Сначало надо поставить фокус
		- Курсор в конец поля ввода
		  (* Есть случаи с формами когда на поле есть маска
		    тогда сначало надо кликнуть по полю, потом 
			нажать home и потом начинать печатать)
		- Посимвольный ввод
		  (Ввод производится относительно медленно)
        - keyDown, keyUp, keyPress (браузер делает задержки после каждой эмуляции)
		  
======================
= Очистка поля ввода =
======================
	* clear и submit
		clear - лучше использовать для текстовых полей ввода.
		(Для очистки чекбокса лучше написать соб-ю ф-ю 
		 с проверкой.
		 Нельзя принименять для файловых полей ввода.
		)
		https://www.w3.org/TR/webdriver/#dfn-element-clear
		------------------------------------------------------
		submit - отправляет форму или завершает заполнение поля.
		(В стандарте не описана)
		
================================================
= (Advanced Interactions API) Сложные действия =
================================================
	* Два подхода к действиям 
		- обычные действия 
			(click и sendKeys) "do what i mean".
			(click подуразумиваем нажать и отпустить)
		
		- Advanced Interaction API
			"do what i say"
			(click можно нажать и держать)
	 
	* Advanced Interactions API команды(небольшой список):
		- click(clickAndHold + release)
		- sendKeys (keyDown+keyUp)
		- clickAndHold (удерживаение мыши)
		- moveToElement/moveByOffset
		- release (отпустить клавишу мыши)
		- keyDown (нажатие клавиши)
		- keyUp (возврат клавиши)
		
https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/interactions/Actions.html		
	 
	* Пример перетаскивания эл-та с зажатой кнопкой ctrl.
		new Actions(driver) // инициал. объект типа Actions
		 .moveToElement(drag) // перем. мышь на эл. drag
		 .keyDown(Keys.CONTROL) // нажать кн. CONTROL
		 .clickAndHold() // нажать и удер. лев. кл. мыши
		 .moveToElement(drop) // перем. мышь на эл. drop
		 .release() // отпускаем к. мыши
		 .keyUp(Keys.CONTROL) // отпускаем CTRL
		 .perform() // Запускаем цепочку действий
	
    * Пример клика по верхниму углу элемента
		new Actions(driver)
		 .moveToElement(el,1,1) //считает сдвиг отн. верхнего левого угла элемента
		 .click()
		 .perform();
	 
	* Пример клика по центру и смещение		
		 new Actions(driver)
		 .moveToElement(el) //перемещ. мыши к центру
		 .moveByOffset(5,5) //cдвиг на указ расстояние
		 .click()
		 .perform();
		 
	* Пример клика по меню
		 new Actions(driver)
		 .moveToElement(menu)
		 .moveToElement(submenu)
		 .moveToElement(item)
		 .click()
		 .perform();
	
	* Пример dragAndDrop
		new Actions(driver)
		.dragAndDrop(el1, el2)
		.perform();
		
=================================
= Работа со сложными элементами =
=================================	
	* Работа с select как вариант:	https://www.selenium.dev/selenium/docs/api/java/org/openqa/selenium/support/ui/Select.html
	
	* Пример заполнения календаря jquery (C#)
		public void SetDatepicker(IWebDriver driver, string cssSelector, string date)
			{
				new WebDriverWait(driver, TimeSpan.FromSeconds(30)).Until<bool>(
					d => driver.FindElement(By.CssSelector(cssSelector)).Displayed);
				driver.FindElement(By.CssSelector(cssSelector)).SendKeys(date);
			}

	* Пример заполнения календаря jquery (C#) jQuery API
		public void SetDatepicker(IWebDriver driver, string cssSelector, string date)
			{
				new WebDriverWait(driver, TimeSpan.FromSeconds(30)).Until<bool>(
					d => driver.FindElement(By.CssSelector(cssSelector)).Displayed);
				(driver as IJavaScriptExecutor).ExecuteScript(
					String.Format("$('{0}').datepicker('setDate', '{1}')", cssSelector, date));
			}
	
=======================
= Невидимые элементы  =
=======================
	* Элементы можно сделать видимыми и работать с ними.
	* Работать через driver.execute_script("arguments[0].selectedIndex = 3", select), работая с select и другими элементами. JavaScript помогает обойти некоторые ограничения.
	
===============================
= Ожидание появление элемента =
===============================	
    * Неявное ожидание 
		driver.manage().timeouts()
		.implicitlyWait(30, TimeUnit.SECONDS);
		- findElement ждет пока элемент появится, и в случ. отс-я эл. вылетит Exception
		- findElements ждет, пока хотя бы один элемент 
			появится и в случ. отс-я эл. вернет пустой список.
		
	* Явное ожидание		
		WebDriver wait = new WebDriverWait(driver, 30);	
		- Ожидание появление эл.та (лямда ф-я)
			WebElement element = wait.until(
			d->d.findElement(locator));
	    - Ожидание появление эл.та (класс ExpectedConditions)
			WebElement element = wait.until(ExpectedConditions
			.presenceOfElementLocated(locator));
	===========
	=Сравнение=
	===========	
	* Явное ожидание(для появления большого кол-во эл-в)
		- на стороне клиента
		- ждать можно чего угодно 
		- надо писать явно
		- TimeoutException
		- Много сетевых запросов (проблема если это делаем в облаке)
	* Неявное ожидание (только для появление эл-та)
		- На стороне браузера
		- Ожидание пооявления DOM
		- Работают автоматически
		- NoSuchElementException
		- Один сетевый запрос
		
=====================================
= Проверка наличие отсутствия эл-та =
=====================================
	
	* Проверка наличия эл-та с ожиданием
	  ----------------------------------
		boolean isElementPresent(WebDriver driver, By locator){
			try{
				driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
				return driver.findElements(locator).size() > 0;
			}finally{
				driver.manage().timeouts().implicitlyWait(0,TimeUnit.SECONDS)
			}
		}
		
	!!!Очень аккуратно с проверкой на отсутствие элементов с использованием implicitlyWait.	
	!!!так как при вызове isElementPresent(driver, By.id("login_form")), вызывается
	ф-я findElement, к-я ждет появления элемента с использованием метода implicitlyWait, а эл-та по факту нет и не будет. Лучше использовать сл-ю ф-ю.	
	
	* Проверка отсутствия эл-та (без ожидания)
      ----------------------------------------
		boolean isElementNotPresent(WebDriver driver, By locator){
			try{
				driver.manage().timeouts().implicitlyWait(0, TimeUnit.SECONDS);
				return driver.findElements(locator).size() == 0;
			}finally{
				driver.manage().timeouts().implicitlyWait(10,TimeUnit.SECONDS)
			}
		}
		
	* Вывод лучше проверять наличие какого либо эл-та на внутр. стр. 
	чем проверять на отсутствие эл-та
	assertTrue(isElementPresent(driver, By.id("login_form")));
	
===============================
= Ожидание исчезновения эл-та =
===============================
	* Исчезновение это не отсутствие.
	* Раньше был, потом исчез.
	* Сначало надо найти, потом ждать исчезновения	
		wait.until(ExceptedConditions.stalenessOf(element));
		
	* Лучше использовать когда эл.ты на странице обновились а
	локаторы остались прежними

============================
= Ожидание видимости эл-та =
============================
	// Проверка видимости э-та
	wait.until(visibilityOf(element));
	
	// Проверка видимости нескольких э-тов
	wait.until(visibilityOfAllElements(element));
	
	// Проверка невидимости э-та
	wait.until(not(visibilityOf(element)));
	
	//Проверка невидимости нескольких э-тов
	wait.until(invisibilityOfAllElements(elementList));
	
	//проверяем видимость э-в к-е потоянно находятся на стр.
	wait.until(visibilityOfAllElementLocatedBy(locator));
	
================================
= Другие условия ожидания э-та =
================================	
	
	
	












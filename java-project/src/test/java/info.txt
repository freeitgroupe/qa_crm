Инфраструктура.
    Среда разработки - IDEA
    Сборщик - Gradle
    Хранилище пакетов - Maven Central
    Тестовый фреймворк - jUnit

Модуль состоит из двух частей
    main - модуля для прогрммы
    test - модуль для тестов

При подключении зависимостей можем указывать тип зависимостей
    dependencies {
        testCompile - режим подключения для тестовой части
        Compile - подключаем для всех модулей
        implementation 'org.seleniumhq.selenium:htmlunit-driver:2.47.1'
    }
======================
Классификация команд
======================
    *Инициализация драйвера -
         который запускает браузера (создается объект класса, при вызове конструктора запускается вспомогательный исполняемый файл, который запускает браузер). Не может уже подключиться к браузеру который уже запущен.
    *Настройка драйвера -
        таймаут, удаление и добавлени куки и др.
    *Действия со страницами -
        переход на страницу, форвард бэк
    *Действия с окнами -
        переключаться м-у окнами, умеет закрывать текущее окно.
    *Действия с диалогами -
        окошки при работе с браузерами (ok, cancel), окна при подгрузке файлов.
    *Поиск элементов (владеть в совершенстве) -

    *Свойства элементов -
        что за тег, какие атрибуты, положение элемента на странице, стили, шрифт, цвет.

    *Действия с элементами -
        нажатие клавиатуры и нажатие мышки

    *Действия с фреймами -
        работами с окнами фрейма

    *Выполнения js кода -
        выполнение кода на странице приложения
======================
=Открытие страницы
======================
    https:// - вводить обязтельно
    driver.get("https://www.google.com");

=====================
 = Поиск элементов =
=====================
    Выполнять поиск элемента перед использованием
    NoSuchElementException - ошибка при поиске элемента.

===================
 = Capabilities =
===================
    Используется чтобы передовать конфигурацию браузеру, передаются в конструктор драйвера.
    по факту часть настроек передается опции командной строки при запуски браузера, другая часть
    настроек   может внедряться в запущенный браузер.

    // передаем параметры в конструктор вебдрайвера.
    var-1
    ChromeOptions options = new ChromeOptions();
    options.addArguments("start-fullscreen");
    driver = new ChromeDriver(options);

    //or var-2 если надо указать еще дополнительные настройки типа прокси.
    ChromeOptions options = new ChromeOptions();
    options.addArguments("start-fullscreen");
    DesiredCapabilities caps = new DesiredCapabilities();
    caps.setCapability(ChromeOptions.CAPABILITY, options);
    driver = new ChromeDriver(caps);

===================
= Псевдо браузеры =
===================
    Их большое количество но по факту реализация не самая лучшая и селениум не все поддерживает. Сейчас актуально использовать Docker, где можно упаковать браузер внутрь контейнера и там запускается.

===================
  = Cookies =
===================
    * Предварительный вход (добавление cookies).
    * Аутентификация в социальных сетях
    * Очистка сессии (удаление всех cookies)
    * Удаляются куки только для текущей страницы (домена), но лучше перезапустить браузер и почистятся все куки.

==========================
= Несколько браузеров =
==========================
    * Надо быть внимательным с IE много нюансов.

==================================
= Параллельный запуск браузеров =
==================================
    * Возможен только в java
    * Можно использовать для параллельного запуска браузеров вспомогательный
     класс webdriverFactory

==============================
= DOM(Document Object Model) =
==============================
    Осуществляется поиск в объектной модели документа

==============================
= Локаторы =
==============================
    Стратегии поиска -
      * By.id
      * By.tagName
      * By.className
      * By.cssSelector
      * By.name
      * By.linkText
      * By.partialLinkText
      * By.xpath

      driver.findElement(By.id("first"));
      driver.findElement(By.name("first"));
      driver.findElement(By.xpath("first"));
      driver.findElement(By.tagName("table"));
      driver.findElement(By.className("first"));
      driver.findElement(By.cssSelector("#first"));
      driver.findElement(By.linkText("Cсылка на страницу"));
      driver.findElement(By.partialLinkText("Cсылка"));
      // Выстраиный запрос в цепочку
      driver.findElement(By.id("second")).findElement(By.tagName("a"));

==============================
= Css - селекоры =
==============================
    Специальные атрибуты -
        id - ("#username")
        class - (".username")

    Проверка значений атрибута
         [checked] - наличие атрибута
         [name = email] - совпадение значение
         [title *= Name] - содержит текст
         [src ^= http] - начинается с текста
         [src $= .pdf] - заканчивается текстом

    Отрицание условий
        "label:not(.error)" - сообщения не об ошибках
        "input:not([type = text])" - не текстовые поля
        "a:not([href ^= http])" - локальные ссылки

    Движение по дереву (состовные селекторы)
        "div#main p " -
        "div#main > p " - p родитель которого div#main
        "div#main li:first-child " -
        "div#main li:last-child " -
        "div#main li:nth-child(1)" -
        "div#header > div:nth-of-type(1)" -

==============================
= Локаторы на основе XPath =
==============================
    Язык запросов XPath был создан для работы с xml документами
    "//*[@checked]" -
        "//" найти где то на странице, * - любой тег
    "//div[@id = 'main']/p" -
        найти тег div c id = main и там найти доч. элемент p
    form = driver.findElement(...);
    input = form.findElement(By.xpath('.//div[@id = 'main']/p'))
         ".//" найти относительно текущего элемента form.

    * Проверка значения атрибута
        Css - селекторы       XPath - запросы
        [checked]             //*[@checked]
        [name = email]        //*[@name = 'email']
        [title *= Name]       //*[contains(@title, 'Name')]
        [src ^= http]         //*[@starts-with(@src, 'http')]
        [src $= .pdf]

    * Комбинация условий
        Css - селекторы                   XPath - запросы
        "label"                           "//label"
        ".error"                          "//*[contains(@class, 'error')]"
        "label.error"                     "//label[contains(@class, 'error')]"
        "label.error.fatal"               "//label[contains(@class, 'error') and contains(@class, 'fatal')]"
        "label.error.fatal[for = email]"  "//label[contains(@class, 'error') and contains(@class, 'fatal') and @for='email']"

    * Движение по дереву CSS vs XPath
        Css - селекторы                         XPath - запросы
        "div#main p"                            "//div[@id = 'main']"
        "div#main > p"                          "//div[@id = 'main']/p"
        "div#main li:first-child"               --/--/--
        "div#main li:last-child"                --/--/--
        "div#header > div:nth-of-type(2)"       "//div[@id='main']/div[2]"

    * XPath мощнее чем CSS
        - Движение в любом направлении
            /../ - движение вверх по дереву элементов
            "//input[@id='search']/../input[@type='button']"
        - Поиск по тексту
            //a[contains(.,'Edit')]
        - Подзапросы
             Поиск input[@name='password'] относительно текущего тега form.
            //form[.//input[@name='password']]

============================
= Сравнение типа локаторов =
============================
   * Смотря как сравнивать
        Мощность запросов - XPath
        Краткость и понятность - CSS (важный момент)
        Скорость - CSS (с минимальным преимуществом)

===============================
= Поиск относительно элемента =
===============================
    * Контекст поиска -
        объект в котором вызывается команда findElement.

    driver.findElement(...) -
        контекст поиска вся страница.
    form = driver.findElement(...);
    input = form.findElement(By.xpath('.//div[@id = 'main']/p'))
        ".//" - контекст поиска form.

===============================
= Поиск нескольких элементов  =
===============================
    * Проверка наличия локатора
        Один из оптимальныз вариантов проверки.
            boolean isElementPresent(WebDriver driver, By locator){
                return driver.findElements(locator).size() > 0;
            }
         В других случаях надо быть внимательным так как
         при каждом падении селениум может делать скриншоты и это
         занимает пространство на диске.

======================
= Элемент не найден  =
======================
    * Желательно перехватывать больше исключений, так как могут подавляться
    исключения которые покажут реальную картину событий и скроют некоторые  баги
    геккодрайвера или хром драйвера. Подход (FailFast), падай как можно быстрее.

    boolean isElementPresent(Webdriver diver, locator){
        try{
            driver.findElement(locator);
            return true;
        //так можем определить не валидный локатор
        }catch(InvalidSelectorException ex){
            throw ex;
        }catch(NoSuchElementException ex){
            return false;
        }
    }
================================
= Ожидание появление элемента  =
================================
    * Причины ожидания
        - Не та страница открыта (можно сделать скриншот для проверки)
        - Неправильный локатор
        - Элемент находится внутри фрейма
        - Нужно немного подождать (подгрузка страницы)

    * Неявные(implicitlyWaiе) и Явные (Explicit Wait) ожидания
        - Неявное (косвенное, скрытое) ожидание устанавливается один раз в коде вне
            операции поиска и действительно до изменения. Не очень удобно если надо
            проверить отсутствие элемента, так как постоянно будет подвесать.
            //изменили настройки браузера
            driver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);

        - Явное
            (непосредственное, прямое) ожидание используется "здесь и сейчас"
            на один конкретный поиск элемента.
            WebElement explicitWait = (new WebDriverWait(driver, 10))
            // или пока не появился элемент с id=bar
              .until(ExpectedConditions.presenceOfElementLocated(By.id("bar")));

==============================
= Построение локаторов =
==============================
    * Устойчивы к изменениям верстки

